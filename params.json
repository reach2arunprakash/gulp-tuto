{"name":"Apprendre Gulp","tagline":"Créer un projet Gulp avec Browserify","body":"Apprendre Gulp\r\n===\r\n\r\nGulp est un système de build comparable à Grunt qui se base sur le système de \"stream\" de NodeJS pour effectuer des tâches plus ou moins complexes.\r\n\r\n\r\nTout au long du tutoriel, pour chaque étape, nous allons créer des versions du code sur le dépôt Github du projet, de manière à ce vous puissiez vous référer au code tel qu'il devrait être et suivre ses évolutions. En cas de problèmes vous pourrez toujours revenir en arrière juste en reprenant le code de l'étape précédente.\r\n\r\nLes tags sur le dépôt Github sont accessibles à cette adresse : <https://github.com/Mnemotix/gulp-tuto/tags>\r\n\r\n[Sommaire :](id:toc)\r\n---\r\n* [Step 0 : Installation](#step-0--installation)\r\n* [Step 1 : Les tâches](#step-1--les-tâches)\r\n* [Step 2 : Les instructions de base](#step-2--les-instructions-de-base)\r\n* [Step 3 : Les plugins](#step-3--les-plugins)\r\n* [Step 4 : Les watchers](#step-4--les-watchers)\r\n* [Step 5 : Synchronisation avec le navigateur](#step-5--synchronisation-avec-le-navigateur)\r\n* [Step 6 : Intégration avec Browserify](#step-6--intégration-avec-browserify)\r\n* [Step 7 : Optimisation du build avec Watchify](#step-7--optimisation-du-build-avec-watchify)\r\n* [Conclusion](#conclusion)\r\n\r\n---\r\n\r\nStep 0 : Installation\r\n---\r\nLa première étape consiste à installer gulp en tant que module global npm et à l'enregristrer parmi les dépendances de développement de votre projet:\r\n\r\n```sh\r\nnpm install -g gulp\r\nmkdir myapp\r\ncd myapp\r\nnpm init\r\nnpm install --save-dev gulp\r\n```\r\n\t\r\nA partir de là Gulp est installé et prêt à exécuter toutes les tâches de build de votre projet. Il manque néanmoins une étape pour que Gulp soit complètement fonctionnel : le `gulpfile.js`\r\n\r\n```sh\r\ntouch gulpfile.js\r\n```\r\n\r\nStep 1 : Les tâches\r\n---\r\nLe `gulpfile` est un fichier javascript qui va contenir toutes les tâches que gulp va pouvoir effectuer pour vous. La première tâche à configurer est la tâche par défaut. Ajoutez la commande suivante dans votre gulpfile : \r\n\r\n```js\r\nvar gulp = require('gulp');\r\n\r\ngulp.task('default', function() {\r\n\tconsole.log('Hello world.');\r\n});\r\n```\r\n\t\r\nSauvegardez et exécutez la commande `gulp` vous devriez avoir une sortie qui ressemble à ça : \r\n\r\n```sh\r\n[14:35:37] Using gulpfile ~/Dev/tutorials/jdev2015/gulp-tuto/gulpfile.js\r\n[14:35:37] Starting 'default'...\r\nHello world.\r\n[14:35:37] Finished 'default' after 106 μs\r\n```\r\n\t\r\nLes tâches Gulp peuvent également être décomposées et chaînées. Modifiez le fichier `gulpfile.js` de la manière suivante :\r\n\r\n```js\r\nvar gulp = require('gulp');\r\n\r\ngulp.task('hello', function () {\r\n    console.log(\"Hello, \");\r\n});\r\n\r\ngulp.task('world', function () {\r\n    console.log(\"world!\");\r\n});\r\ngulp.task('default', ['hello', 'world']);\r\n```\r\n\r\nNous avons défini deux tâches distinctes et la tâche par défaut qui appelle les deux autres. Vous pouvez essayer les commandes suivantes :\r\n\r\n```sh\r\ngulp hello\r\ngulp world\r\ngulp\r\n```\r\n\t\r\nL'ordre dans lequel les tâches sont chaînées compte, par exemple si on remplace le code de la tâche par défaut avec `gulp.task('default', ['world', 'hello']);`, nous verrons que la tâche `world` est appellée avant la tâche `hello`.\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step1)\r\n\r\nStep 2 : Les instructions de base\r\n---\r\n\r\nGulp propose quelques instructions de base pour la manipulation des fichiers et des dossiers.\r\n\r\n* `gulp.src` : sélectionne un ensemble de fichiers sources\r\n* `pipe` : opérateur qui permet de chainer les opérations\r\n* `gulp.dest` : copie le résultat de la chaine de traitement vers un répertoire de destination.\r\n\r\nModifions à présent la structure du répertoire de manière à avoir le squelette d'une application qui ressemblerait à cela : \r\n\r\n\t.\r\n\t├── README.md\r\n\t├── client\r\n\t│   ├── app\r\n\t│   │   ├── app.js\r\n\t│   │   ├── collections\r\n\t│   │   │   └── collections.js\r\n\t│   │   ├── models\r\n\t│   │   │   └── models.js\r\n\t│   │   └── views\r\n\t│   │       └── views.js\r\n\t│   ├── assets\r\n\t│   │   ├── favicon.ico\r\n\t│   │   ├── images\r\n\t│   │   │   └── shlurp.png\r\n\t│   │   └── styles\r\n\t│   │       └── style.css\r\n\t│   └── index.html\r\n\t├── gulpfile.js\r\n\t├── node_modules\r\n\t└── package.json\r\n\r\nEditez le fichier `index.html` \r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title>My App</title>\r\n    <link rel=\"shortcut icon\" href=\"img/favicon.ico\">\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\r\n</head>\r\n<body>\r\n    <h1>Gulp rocks!</h1>\r\n    <p><img src=\"img/shlurp.png\"/></p>\r\n\r\n<!-- Scripts -->\r\n<script src=\"js/models/models.js\"></script>\t<script src=\"js/collections/collections.js\"></script>\r\n<script src=\"js/views/views.js\"></script>\r\n<script src=\"js/app.js\"></script>\r\n<!-- /Scripts -->\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\nEditez le fichier `app.js`\r\n\r\n```js\r\nconsole.log(\"Application has started...\");\r\n```\r\n\r\nEditez le fichier `models.js`\r\n\r\n```js\r\nconsole.log(\"Models have been loaded.\");\r\n```\r\n\r\nEditez le fichier `collections.js`\r\n\r\n```js\r\nconsole.log(\"Collections have been loaded.\");\r\n```\r\n\r\nEditez le fichier `views.js`\r\n\r\n```js\r\nconsole.log(\"Views have been loaded.\");\r\n```\r\n\r\nA présent, pour illustrer le fonctionnement des instructions de base de Gulp, nous allons éditer le `gulpfile` de la manière suivante :\r\n\r\n```js\r\nvar gulp = require('gulp');\r\n\r\n// Scripts\r\ngulp.task('scripts', function () {\r\n    return gulp.src('./client/app/**/*.js')\r\n        .pipe(gulp.dest('./dist/js'));\r\n});\r\n\r\n// Stylesheets\r\ngulp.task('styles', function () {\r\n    return gulp.src('./client/assets/**/*.css')\r\n        .pipe(gulp.dest('./dist/css'));\r\n});\r\n\r\n// Images\r\ngulp.task('images', function () {\r\n    return gulp.src(['./client/assets/**/*.png', './client/assets/**/*.ico'])\r\n        .pipe(gulp.dest('./dist/img'));\r\n});\r\n\r\n// HTML\r\ngulp.task('html', function () {\r\n    return gulp.src('./client/**/*.html')\r\n        .pipe(gulp.dest('./dist'));\r\n});\r\n\r\n// Default\r\ngulp.task('default', ['html', 'scripts', 'styles', 'images']);\r\n```\r\n\r\nNous avons donc défini trois tâches de base qui vont respectivement sélectionner les fichiers de l'application par leur extension et les copier dans le répertoire \"dist\". La commande par défaut va exécuter toutes ces tâches les unes après les autres.\r\n\r\n```sh\r\n$ gulp\r\n[15:37:18] Using gulpfile ~/Dev/tutorials/gulp/gulp-tuto/gulpfile.js\r\n[15:37:18] Starting 'html'...\r\n[15:37:18] Finished 'html' after 5.94 ms\r\n[15:37:18] Starting 'scripts'...\r\n[15:37:18] Finished 'scripts' after 1.68 ms\r\n[15:37:18] Starting 'styles'...\r\n[15:37:18] Finished 'styles' after 749 μs\r\n[15:37:18] Starting 'default'...\r\n[15:37:18] Finished 'default' after 2.49 μs\r\n```\r\n\r\nUn petit coup d'oeil sur le dossier 'dist' qui a été créé : \r\n\r\n```sh\r\n$ tree ./dist\r\n./dist\r\n├── css\r\n│   └── style.css\r\n├── img\r\n│   ├── favicon.ico\r\n│   └── shlurp.png\r\n├── index.html\r\n└── js\r\n    ├── app.js\r\n    ├── collections\r\n    │   └── collections.js\r\n    ├── models\r\n    │   └── models.js\r\n    └── views\r\n        └── views.js\r\n```\r\n\r\n\r\nIl ne reste plus qu'à afficher tout ça dans le navigateur :\r\n\r\n```sh\r\n$ open ./dist/index.html\r\n```\r\n\r\nBien que cela puisse déjà s'avérer utile, ce n'est qu'un début.   \r\nComme nous allons le voir, Gulp peut faire bien plus que ça.\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step2)\r\n\r\nStep 3 : Les plugins\r\n---\r\n\r\nGulp dispose d'une [masse impressionante de plugins](http://gulpjs.com/plugins/) et la communauté des utilisateurs de Gulp continue d'en rajouter en permance.\r\n\r\nLes plugins permettent d'appliquer des traitements très variés entre le moment où les fichiers sont sélectionnés par l'instruction `gulp.src`et le moment où ils sont copiés dans avec `gulp.dest`. Ces plugins sont appliqués grâce à l'instruciton `pipe`.\r\n\r\nL'instruction type dans Gulp est donc de la forme suivante :\r\n\r\n```js\r\ngulp.src(<selecteurs>, <options>)\r\n    .pipe(plugin1(params))\r\n    .pipe(plugin2(params))\r\n    ...\r\n    .pipe(pluginN(params))\r\n    .pipe(gulp.dest(<destination>));\r\n```\r\n\r\n\r\nIl existe des plugins pour à peu près tout. Ca peut être pour minifier les scripts ou les feuilles de styles, pour valider la syntaxe du javascript, pour compiler les fichiers coffeescript, less, sass, dart, pour transformer les templates en script JS, pour compresser les images, etc... \r\n\r\nLa liste est longue et l'objectif de ce tutoriel n'est pas de les couvrir tous. Nous allons donc nous concentrer sur les plugins les plus utilisés/utiles.\r\n\r\n```sh\r\nnpm install --save-dev del gulp-less gulp-jshint gulp-concat gulp-uglify\r\n```\r\n\r\nRapidement :\r\n\t\r\n* `gulp-less` : permet de compiler les fichiers less (il existe un équivalent pour sass)\r\n* `gulp-jshint` : permet de valider la qualité du code javascript.\r\n* `gulp-concat` : permet de concaténer plusieurs fichiers en un seul\r\n* `gulp-uglify` : salit le code JS pour empêcher qu'il soit lisible une fois déployé en prod.\r\n* `del` : permet de supprimer des fichiers ou des dossiers\r\n\r\nCes dépendances sont sauvées en tant que dépendances de développement.\r\nUne fois ces dépendances installées, il faut les importer dans le `gulpfile` : \r\n\r\n```js\r\nvar gulp = require('gulp');\r\nvar jshint = require('gulp-jshint');\r\nvar less = require('gulp-less');\r\nvar concat = require('gulp-concat');\r\nvar uglify = require('gulp-uglify');\r\nvar rename = require('gulp-rename');\r\nvar del = require('del');\r\n```\r\n\r\nPour plus de lisibilité et dans l'esprit du \"don't repeat yourself\", nous allons mutualiser les chemins de l'application dans un objet JS : \r\n\r\n```js\r\nvar paths = {\r\n    dist    : './dist',\r\n    scripts : './client/app/**/*.js',\r\n    styles  : './client/assets/styles/**/*.less',\r\n    html    : './client/**/*.html',\r\n    images  : ['./client/assets/favicon.ico', './client/assets/images/**/*.*']\r\n};\r\n```\r\n\r\nTout d'abord, nous allons rajouter les tâches de \"cleaning\" qui serviront à supprimer du dossier 'dist' certains fichiers avant l'exécution des tâches : \r\n\r\n```js\r\n/*\r\n * Cleans the dist directory\r\n */\r\ngulp.task('clean:scripts', function (cb) {\r\n    del(paths.dist + '/js', cb);\r\n});\r\n\r\ngulp.task('clean:styles', function (cb) {\r\n    del(paths.dist + '/css', cb);\r\n});\r\n\r\ngulp.task('clean:images', function (cb) {\r\n    del(paths.dist + '/images', cb);\r\n});\r\n\r\ngulp.task('clean:html', function (cb) {\r\n    del(paths.dist + '/**/*.html', cb);\r\n});\r\n```\r\n\r\nNous allons également renommer le fichier `style.css` en `style.less` et éditer son contenu de manière à avoir :\r\n\r\n```less\r\n@bg-color : pink;\r\n@fg-color : white;\r\nbody{\r\n    background-color: @bg-color;\r\n    color:@fg-color;\r\n}\r\n```\r\n\r\nEnsuite nous allons changer la tâche 'styles' de manière à récupérer les fichiers .less et pas les .css et à les transformer à la volée.\r\n\r\n\r\n```js\r\n/*\r\n * Compiles less files into css\r\n */\r\ngulp.task('styles', ['clean:styles'], function () {\r\n    return gulp.src(paths.styles)\r\n        .pipe(less())\r\n        .pipe(gulp.dest(paths.dist + '/css'));\r\n});\r\n```\r\n\r\nDe la même manière nous allons pouvoir traiter les fichiers javascript, les valider avec JSLint, les concaténer dans un seul fichier et les minifier pour la prod : \r\n\r\n```js\r\n/*\r\n * Checks the validity of JS code\r\n */\r\ngulp.task('lint', function () {\r\n    return gulp.src(paths.scripts)\r\n        .pipe(jshint())\r\n        .pipe(jshint.reporter('default'));\r\n});\r\n\r\n/*\r\n * Concatenates & uglifies JS scripts into a single file\r\n */\r\ngulp.task('scripts', ['clean:scripts'], function () {\r\n    return gulp.src(paths.scripts)\r\n        .pipe(uglify())\r\n        .pipe(concat('scripts.min.js'))\r\n        .pipe(gulp.dest(paths.dist + '/js'));\r\n});\r\n```\r\n\r\nOn met également à jour les autres tâches : \r\n\r\n```js\r\n/*\r\n * Copies html files to dist directory\r\n */\r\ngulp.task('html', ['clean:html'], function () {\r\n    return gulp.src(paths.html)\r\n        .pipe(gulp.dest(paths.dist));\r\n});\r\n\r\n/*\r\n * Copies images files to dist directory\r\n */\r\ngulp.task('images', ['clean:images'], function () {\r\n    return gulp.src(paths.images)\r\n        .pipe(gulp.dest(paths.dist + '/img'));\r\n});\r\n```\r\n\r\nPour plus de lisibilité, nous allons créer une tâche 'build' qui construira l'intégralité du répertoire 'dist' : \r\n\r\n```js\r\ngulp.task('build', [\r\n    'lint',\r\n    'html',\r\n    'images',\r\n    'scripts',\r\n    'styles'\r\n]);\r\ngulp.task('default', ['build']);\r\n```\r\n\r\nOn modifie le fichier `./client/index.html`:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title>My App</title>\r\n    <link rel=\"shortcut icon\" href=\"img/favicon.ico\">\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\r\n</head>\r\n<body>\r\n\r\n    <h1>Gulp rocks!</h1>\r\n    <p><img src=\"img/shlurp.png\"/></p>\r\n\r\n<!-- Scripts -->\r\n<script src=\"js/scripts.min.js\"></script>\r\n<!-- /Scripts -->\r\n\r\n</body>\r\n</html>\r\n```\r\n\t\r\nUne fois les modifications faites, nous pouvons vérifier que le tout fonctionne correctement :\r\n\r\n```sh\r\n$ gulp\r\n$ open ./dist/index.html\r\n```\r\n\r\nVous devriez obtenir un résultat qui ressemble à ça : \r\n![screenshot](http://puu.sh/iEY3E/54992f328d.png =500x)\r\n\r\nLe problème ici vient du fait que si notre client était une véritable Single Page Application alors le script `app.js`devrait être chargé en dernier, or là nous voyons qu'il est appelé en premier. De même, dans le cas de Backbone, il est important que les modèles soient chargés avant les collections sous peine d'avoir une exception JS au chargement de la page. Il faut donc dire à Gulp l'ordre dans lequel les fichiers doivent être chargés. Pour cela nous allons utiliser un tableau pour déclarer nos fichiers au lieu d'une regex : \r\n\r\n```js\r\nvar paths = {\r\n    dist    : './dist',\r\n    scripts : [\r\n        './client/app/models/models.js',\r\n        './client/app/collections/collections.js',\r\n        './client/app/views/views.js',\r\n        './client/app/app.js'\r\n    ],\r\n    styles  : './client/assets/styles/**/*.less',\r\n    html    : './client/**/*.html',\r\n    images  : ['./client/assets/favicon.ico', './client/assets/images/**/*.*']\r\n};\r\n```\r\n\r\nAvec ce tableau, la concaténation va s'opérer dans le bon ordre :\r\n![screenshot2](http://puu.sh/iEYQF/96fa7a81b7.png =500x)\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step3)\r\n\r\nStep 4 : Les watchers\r\n---\r\n\r\nLe `gulpfile` que nous avons réalisé permet de créer une version statique du client, mais il peut être fastidieux de devoir re-générer le répertoire 'dist' à chaque changement. Idéalement, il faudrait que le build se fasse à la volée. C'est précisément le rôle des `watchers`.\r\n\r\nLes `watchers` vont détecter les moindres changements sur un ensemble de fichiers et vont déclencher, le cas échéant, les tâches qui leur sont associées.\r\n\r\nReprenons notre `gulpfile` et ajoutons lui donc une tâche `watch` :\r\n\r\n```js\r\n/*\r\n* Watches any change in source code and updates\r\n* the dist directory in real time\r\n*/\r\ngulp.task('watch', function () {\r\n   gulp.watch(paths.scripts, ['lint', 'scripts']);\r\n   gulp.watch(paths.styles, ['styles']);\r\n   gulp.watch(paths.html, ['html']);\r\n   gulp.watch(paths.images, ['images']);\r\n});\r\n```\r\n\r\nIl faut ensuite mettre à jour la tâche par défaut :\r\n\r\n```js\r\n/*\r\n* Default task, build everything and watches for changes\r\n*/\r\ngulp.task('default', ['build', 'watch']);\r\n```\r\n\r\nL'exécution de la tâche va donner lieu à un processus de type 'loop' qu'il sera possible d'arrêter à tout moment avec le raccourci `CTRL+C`.\r\n\r\n```sh\r\n$ gulp build\r\n$ open ./dist/index.html\r\n$ gulp watch\r\n```\r\n\r\nMaintenant essayons de modifier le fichier `client/index.html` en changeant le texte de la balise `h1`par exemple :\r\n\r\n```html\r\n<h1>Gulp is watching you!</h1>\r\n```\r\n\r\nUn simple rafraichissement de la page dans le navigateur (`F5` ou `CTRL+R`) devrait permettre de voir apparaître les changements.\r\nSympa non ?\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step4)\r\n\r\nStep 5 : Synchronisation avec le navigateur\r\n---\r\n\r\nNodeJS dispose d'un très bon module pour la synchronisation automatique client/serveur. Etant donné que Gulp est basé sur Node, il peut bénéficier des mêmes fonctionnalités.\r\nLe but avoué étant de ne même plus avoir à appuyer sur `F5`pour rafraichir la page.\r\n\r\nLe module en question est [BrowserSync](http://www.browsersync.io/). Il ne s'agit pas d'un plugin Gulp à part entière, mais il s'intègre très bien en tant que tel. \r\n\r\nInstallation\r\n\t\r\n```sh\r\nnpm install --save-dev browser-sync\r\n```\r\n\r\nImportez le dans le Gulpfile\r\n\r\n```js\r\nvar browserSync = require('browser-sync').create();\r\n```\r\n\r\nCréez une tâche 'serve' à la place de 'watch'\r\n\r\n```js\r\n/*\r\n * Synchronizes the browser with the 'dist' directory\r\n */\r\ngulp.task('serve', ['build'], function () {\r\n    browserSync.init({\r\n        notify: false,\r\n        port: 9000,\r\n        server: {\r\n            baseDir: ['dist']\r\n        }\r\n    });\r\n\r\n    gulp.watch(paths.scripts, ['lint', 'scripts']).on(\"change\", browserSync.reload);\r\n    gulp.watch(paths.styles, ['styles']).on(\"change\", browserSync.reload);\r\n    gulp.watch(paths.html, ['html']).on(\"change\", browserSync.reload);\r\n    gulp.watch(paths.images, ['images']).on(\"change\", browserSync.reload);\r\n});\r\n```\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step5)\r\n\r\nStep 6 : Intégration avec Browserify\r\n---\r\n\r\nLe développement Javascript a grandement évolué depuis l'arrivé de NodeJS. Certaines des techniques de programmation spécifiques à Node se sont démocratisées et sont devenues des quasi-standards.\r\n\r\nL'une des technologies emblématique de Node sont les [modules CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) qui, couplés à NPM, permettent de modulariser très simplement le développement d'une application.\r\n\r\n[Browserify](http://browserify.org/) s'appuie sur NPM pour transformer n'importe quelle application développées avec les modules CommonJS en un script unique qui rassemble tout au moment de passer en production. L'avantage est de ne plus avoir à gérer l'ordre dans lequel les scripts doivent être insérés car le système de résolution des dépendances de NPM garantit que les modules seront chargés dans l'ordre.\r\n\r\nLe couplage de Gulp avec Browserify est très puissant car il permet de développer une application complexe et modulaire et de simplement dire à Browserify de rassembler le tout dans un seul script (`bundle.js`) qui sera au final intégré dans le fichier index.html.\r\n\r\nLa gros avantage par rapport au plugin de concaténation est qu'il n'est pas nécessaire de passer un tableau avec tous les scripts dans l'ordre. De plus, toutes les librairies qui sont utilisables avec NPM (notamment Jquery, Backbone) sont intégrées dans le bundle.\r\n\r\nCommençons par installer Browserify et ses dépendances : \r\n\t\r\n```sh\r\nnpm install --save-dev browserify vinyl-source-stream\r\n```\r\n\r\nIl faut ensuite mettre à jour le `Gulpfile`:\r\n\r\n```js\r\n// Browserify\r\nvar browserify = require('browserify');\r\nvar source = require('vinyl-source-stream');\r\n```\r\n\r\nEt ajouter une tâche correspondante :\r\n\r\n```js\r\ngulp.task('browserify', function() {\r\n    return browserify('./client/app/app.js').bundle()\r\n        .pipe(source('bundle.js'))\r\n        .pipe(gulp.dest('./dist'));\r\n});\r\n```\r\n\r\nCette tâche va prendre le script \"racine\" de l'application et résoudre toutes ses dépendances, les ajouter dans un fichier `bundle.js`et le placer dans le répertoire \"dist\". Quelle différence avec la tâche \"scripts\" des étapes précédentes ? Un petit exemple devrait éclairer tout ça.\r\n\r\nCommençons par installer la librairie Jquery : \r\n\r\n```sh\r\nnpm install --save jquery\r\n```\r\n\r\nVous remarquerez que cette fois çi, la librairie n'est pas installée en tant que dépendance de développement grâce à l'option `--save`au lieu de `--save-dev`.\r\n\r\nEditez le fichier `./client/app/app.js` :\r\n\r\n```js\r\nvar $ = require('jquery');\r\n$('img').fadeOut(); // makes images disappear\r\nconsole.log(\"Application has started...\");\r\n```\r\n\r\nCe script très simple importe la librairie Jquery pour ensuite créer un effet de fade out sur toutes les images de la page.\r\n\r\nReste à mettre à jour le fichier `index.html`pour lui dire d'importer le bon script : \r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title>My App</title>\r\n    <link rel=\"shortcut icon\" href=\"img/favicon.ico\">\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\r\n</head>\r\n<body>\r\n    <h1>Gulp is serving you!</h1>\r\n    <p><img src=\"img/shlurp.png\"/></p>\r\n<script src=\"bundle.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\nExécuter \r\n\r\n```sh\r\ngulp browerify\r\ngulp serve\r\n```\r\n\r\nEt votre image devrait disparaitre toute seule.\r\nA partir de maintenant, la tâche `browserify`peut remplacer la tâche `scripts`des étapes précédentes. \r\n\r\n```js\r\ngulp.task('build', [\r\n    'lint',\r\n    'browserify',\r\n    'html',\r\n    'images',\r\n    'styles'\r\n]);\r\n\r\ngulp.task('serve', ['build'], function () {\r\n    browserSync.init({\r\n    [...]\r\n    });\r\n\r\n    gulp.watch(paths.scripts, ['lint', 'browserify']).on(\"change\", browserSync.reload);\r\n    [...]\r\n});\r\n```\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step6)\r\n\r\nStep 7 : Optimisation du build avec Watchify\r\n---\r\n\r\n\r\nAu fur et à mesure qu'un projet Browserify évolue, la construction du bundle devient de plus en plus longue et peut prendre jusqu'à 30 secondes et plus. Un tel délai de compilation va devenir très vite très pénible pour le développeur.\r\n\r\nC'est pourquoi [substack](http://github.com/substack) a écrit [Watchify](http://github.com/substack/watchify), un compilateur Browserify persistant qui ajoute un watcher sur les fichiers et ne reconstruit __*que le strict nécéssaire*__. De cette manière un build qui pourrait prendre plusieurs dizaines de secondes, ne prend que quelques millisecondes, ce qui représente un énorme gain de productivité.\r\n\r\nWatchify, comme Browserify, ne propose pas de plugin Gulp et il n'en a pas besoin. Nous pouvons utiliser [vinyl-source-stream](http://github.com/hughsk/vinyl-source-stream) pour intégrer le stream Watchify dans la pipeline Gulp.\r\n\r\nCommençons par installer les dépendances nécessaires :\r\n\r\n```sh\r\nnpm install --save-dev gulp-util vinyl-buffer watchify gulp-sourcemaps lodash.assign\r\n```\r\n\r\nEnsuite dans le Gulpfile, il faut compléter les imports : \r\n\r\n```js\r\n// gulfile.js\r\n\r\nvar gulp = require('gulp');\r\nvar jshint = require('gulp-jshint');\r\nvar less = require('gulp-less');\r\nvar del = require('del');\r\nvar gutil = require('gulp-util');\t\t\t\t// new\r\n\r\nvar browserSync = require('browser-sync').create(); \r\n\r\n// Browserify + Watchify\r\nvar browserify = require('browserify');\r\nvar watchify = require('watchify'); \t\t\t// new\r\nvar buffer = require('vinyl-buffer');\t\t\t// new\r\nvar source = require('vinyl-source-stream');\r\nvar sourcemaps = require('gulp-sourcemaps');\t// new\r\nvar assign = require('lodash.assign');\t\t\t// new\r\n\r\n```\r\n\r\nOn peut supprimer la tâche `browserify` précédente et la remplacer par le bloc suivant :\r\n\r\n```js\r\n// Options browserify\r\nvar customOpts = {\r\n    entries: ['./client/app/app.js'],\r\n    debug: true\r\n};\r\n\r\n// Utilisation du module lowdash.assign pour fusionner\r\n// les options browserify et watchify dans un même objet\r\nvar opts = assign({}, watchify.args, customOpts);\r\n\r\n// Initialisation de Watchify\r\nvar bundler = watchify(browserify(opts));\r\n\r\n// Il est possible d'ajouter des transformations ici, par exemple :\r\n// bundler.transform(coffeeify);\r\n\r\nbundler.on('update', bundle); // listener sur l'évènement 'update' pour mettre à jour pour le bundle\r\nbundler.on('log', gutil.log); // log les sorties du bundler sur le terminal\r\ngulp.task('scripts', bundle); // ajout de la tâche `gulp scripts` pour assembler le bundle\r\n\r\nfunction bundle() {\r\n    return bundler.bundle()\r\n        // log les errors quand elles surviennent\r\n        .on('error', gutil.log.bind(gutil, 'Browserify Error'))\r\n        .pipe(source('bundle.js'))\r\n        // optionnel, permet de bufferiser le contenu des fichiers pour améliorer les performances du build\r\n        .pipe(buffer())\r\n        // optionnel, permet d'ajouter les sourcemaps pour le debug\r\n        .pipe(sourcemaps.init({loadMaps: true}))\r\n        // Ecrit les fichiers .map\r\n        .pipe(sourcemaps.write('./'))\r\n        // Copie le tout dans le répertoire final\r\n        .pipe(gulp.dest(paths.dist))\r\n        // stream le résultat à BrowserSync pour qu'il recharge automatiquement la page\r\n        .pipe(browserSync.stream());\r\n}\r\n\r\n```\r\nEnsuite, on met à jour les tâches `build` et `serve` : \r\n\r\n```js\r\n/*\r\n * Macro task to re-build the whole dist directory\r\n */\r\ngulp.task('build', [\r\n\t'lint',\r\n    'scripts',\r\n\t'html', \r\n\t'images',\r\n\t'styles'\r\n]);\r\n\r\n/*\r\n * Synchronizes the browser with the 'dist' directory\r\n */\r\ngulp.task('serve', ['build'], function () {\r\n    browserSync.init({\r\n        notify: false,\r\n        port: 9000,\r\n        server: {\r\n            baseDir: ['dist']\r\n        }\r\n    });\r\n    gulp.watch(paths.scripts, ['lint', 'scripts']);\r\n    gulp.watch(paths.styles, ['styles']);\r\n    gulp.watch(paths.html, ['html']).on(\"change\", browserSync.reload);\r\n    gulp.watch(paths.images, ['images']).on(\"change\", browserSync.reload);\r\n});\r\n\r\n```\r\n\r\n[Code source complet de cette étape](https://github.com/Mnemotix/gulp-tuto/tree/Step7)\r\n\r\n\r\nConclusion\r\n---\r\n\r\nAvec ce tutoriel, nous avons pu effleurer l'ensemble des possibilités offertes par Gulp.\r\nLe projet final de ce tutoriel nous donne des bases solides pour la construction d'applications fullstack JS et nous servira de point de départ dans les prochains chapitres de notre formation.\r\n\r\nVous pouvez retrouver le code source complet du projet, dans son état final, [à cette adresse](https://github.com/Mnemotix/gulp-tuto) ou bien en utilisant la ligne de commande GIT : \r\n\r\n\tgit clone https://github.com/Mnemotix/gulp-tuto.git myproject\r\n","google":"UA-64642317-2","note":"Don't delete this file! It's used internally to help with page regeneration."}